from ib_insync import *
from src.utils.logger import logger
from src.utils.managers.connection_manager import ConnectionManager

class OrderManager:
    """
    Handles order submission and position management via IBKR.
    """

    def __init__(self, conn: ConnectionManager):
        self.conn = conn
        self.ib = conn.ib

    def place_order(self, strategy, orders):
        """Place orders generated by a strategy.
        Parameters
        ----------
        strategy : Strategy instance that produced the order, required to locate
                    contract information (using `strategy.params.get_mes_data`).
        orders : Iterable[ib_insync.Order]
        """
        logger.info(f"Placing order(s): {orders}")
        if not self.conn.is_connected():
            logger.warning("No connection when placing order. Attempting reconnection…")
            if not self.conn.reconnect():
                raise Exception("Cannot place order - no connection to IBKR")

        async def _place():
            # Use the first contract defined in the strategy parameters.  All
            # strategies are expected to keep the live market data *inside* their
            # ContractData objects, so we can rely on `params.contracts`.
            if not getattr(strategy.params, "contracts", None):
                logger.error("Strategy params does not contain any contracts – aborting")
                return False

            contract = strategy.params.contracts[0].contract
            self.ib.qualifyContracts(contract)
            for o in orders:
                logger.debug(f"Submitting order: {o}")
                self.ib.placeOrder(contract, o)
            return True

        try:
            self.conn._execute(_place())
            logger.success("Order(s) submitted to IBKR.")
            return True
        except Exception as e:
            logger.error(f"Error placing order: {str(e)}")
            raise

    def close_all_positions(self):
        logger.info("Closing all positions…")
        if not self.conn.is_connected():
            logger.warning("No connection when closing positions. Attempting reconnection…")
            if not self.conn.reconnect():
                raise Exception("Cannot close positions - no connection to IBKR")

        async def _close():
            for order in self.ib.orders():
                self.ib.cancelOrder(order)
            logger.success("Successfully closed all positions")
            return True

        try:
            self.conn._execute(_close())
            return True
        except Exception as e:
            logger.error(f"Error closing all positions: {str(e)}")
            raise
